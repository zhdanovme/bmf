---
description: Generate test cases (_test-cases.yaml) from epics and tag entities with tc:* markers.
---

## User Input

```text
$ARGUMENTS
```

## Overview

Analyze BMF specification files based on epics and generate comprehensive story-based test cases in `_test-cases.yaml`. Tags entities with `tc:*` markers using yq to establish traceability from test scenarios to implementation.

## Execution

### 1. Parse Arguments

Extract from `$ARGUMENTS`:
- `folder` - path to BMF project folder (e.g., `bmfs/examples/marketplace`)
- `lang` - language for descriptions (default: `en`)

If folder is empty, list available projects in `bmfs/` and ask user to specify.

### 2. Verify Prerequisites

Check if `{folder}/_epics.yaml` exists.

**If NOT exists:**
```
ERROR: _epics.yaml not found in {folder}

Epics are required to generate test cases.
Run: /bmf.create-epics {folder}
```

Stop execution.

### 3. Clean Existing tc:* Tags

Before generating new test cases, remove all existing `tc:*` tags from entities:

```bash
npx ts-node utils/delete-tc-tags.ts {folder}
```

This ensures a clean slate and prevents stale tags from previous generations.

**Output:**
```
Removing tc:* tags...

   spec.yaml
   ...

Modified N file(s)
```

### 4. Read Templates

Read the template from `bmfs/template/_test-cases.yaml` to understand:
- TC ID format (`tc:domain:scenario-name`)
- Description format (scenario + steps + verification)
- Tag conventions (`:start`, `:end`, intermediate)

Read `bmfs/template/_epics.yaml` to understand epic structure.

### 5. Load Epics

Read `{folder}/_epics.yaml` and extract all epics:
- Root epics: `epic:domain`
- Subepics: `epic:domain:subdomain`

Build epic hierarchy map.

### 6. For Each Epic - Analyze Entities

For each epic domain (use deepest level - subepics if available):

**A. Extract entities using yq:**
```bash
# Get all entities matching *:EPIC:* pattern
yq 'to_entries | map(select(.key | test("^[a-z]+:{epic}:"))) | from_entries' {folder}/*.yaml
```

**B. Categorize entities by type:**
- `screen:epic:*` - UI screens (MUST be covered)
- `dialog:epic:*` - modal dialogs (MUST be covered)
- `action:epic:*` - business actions (MUST be covered)
- `event:epic:*` - system events (MUST be covered)
- `entity:epic:*` - data models (optional coverage)
- `component:epic:*` - reusable UI (optional coverage)
- `layout:*` - layouts (optional coverage)
- `context:*` - global state (optional coverage)
- `config:*` - configuration (optional coverage)

**C. Analyze relationships:**
- Follow `$screen.*`, `$action.*`, `$dialog.*` references in `action` fields
- Trace effects chains in actions
- Map navigation flows between screens
- Identify entry points and exit points

### 7. For Each Epic - Generate Test Cases

Based on entity analysis, generate test cases that cover:

**A. Happy Path Scenarios:**
- Main user flows through the feature
- One TC per major screen/action chain
- ID format: `tc:epic:feature-success`

**B. Edge Cases:**
- Error handling paths
- Empty states
- Boundary conditions
- ID format: `tc:epic:feature-error` or `tc:epic:feature-edge-case`

**C. Alternative Paths:**
- Secondary flows
- Optional features
- ID format: `tc:epic:feature-alternative`

### 8. Write _test-cases.yaml

Create/update `{folder}/_test-cases.yaml`:

```yaml
# yaml-language-server: $schema=../../schema.json
# Test Cases - Story Scenarios
#
# Auto-generated by bmf.create-tcs
#
# Tags: tc:X:Y:start (entry), tc:X:Y (step), tc:X:Y:end (exit)

tc:epic:scenario-name:
  description: |
    Brief description of the scenario.

    1. First step - what user does
    2. Second step - system response
    3. Third step - user action
    ...

    Verify: key assertions for testing.
```

**Description format by language:**

**English (en):**
- Use active voice, present tense
- Focus on user actions and system responses
- Keep steps concise

**Russian (ru):**
- Use present tense (настоящее время)
- Focus on user actions (что делает пользователь)
- Brief and clear steps

### 9. Tag Entities with yq

For each generated TC, tag relevant entities:

**A. Identify entry point → tag with `:start`**
```bash
yq -i '.["screen:epic:name"].tags += ["tc:epic:scenario:start"]' {file}
```

**B. Identify intermediate steps → tag without suffix**
```bash
yq -i '.["action:epic:name"].tags += ["tc:epic:scenario"]' {file}
```

**C. Identify exit point → tag with `:end`**
```bash
yq -i '.["screen:epic:name"].tags += ["tc:epic:scenario:end"]' {file}
```

**Tag ordering rule:**
Ensure tags are sorted: `stage:*` first, then `tc:*` alphabetically.

```bash
# Sort tags in entity
yq -i '.["entity:id"].tags |= (sort | unique)' {file}
```

### 10. Cross-Epic Coverage

Some scenarios may span multiple epics. Tag entities from other epics if they are part of the user story:

Example: `tc:checkout:complete-order` may include:
- `screen:checkout:confirm` (checkout epic) → `tc:checkout:complete-order:start`
- `action:cart:clear` (cart epic) → `tc:checkout:complete-order`
- `dialog:orders:success` (orders epic) → `tc:checkout:complete-order:end`

### 11. Run Coverage Check

Execute coverage check:
```bash
npx ts-node utils/check-tcs.ts {folder}
```

This will report:
- Covered entities (screen/dialog/action/event with tc:* tags)
- Uncovered entities that MUST be covered
- Optional entities without coverage (info only)

### 12. Fix Uncovered Entities

If check-tcs reports uncovered entities:

**A. For each uncovered screen/dialog/action/event:**
1. Analyze what scenario it belongs to
2. Either:
   - Add to existing TC if it's part of that flow
   - Create new TC if it represents new user story

**B. Tag the entity:**
```bash
yq -i '.["entity:id"].tags += ["tc:domain:scenario"]' {file}
```

**C. Re-run check-tcs** until all required entities are covered.

### 13. Report Summary

After completion, report:

```
Test Cases Generated:
  Total: N
  By epic:
    - epic:auth: 3 TCs
    - epic:cart: 2 TCs
    ...

Coverage:
  ✅ Screens: M/M covered
  ✅ Dialogs: M/M covered
  ✅ Actions: M/M covered
  ✅ Events: M/M covered

Files modified:
  - {folder}/_test-cases.yaml (created/updated)
  - {folder}/screen.yaml (tagged)
  - {folder}/action.yaml (tagged)
  ...
```

## Example Output

For marketplace project:

```yaml
# yaml-language-server: $schema=../../schema.json
# Test Cases - Story Scenarios

# --- AUTH ---

tc:auth:login-success:
  description: |
    User logs in with valid credentials.

    1. User opens login screen
    2. Enters email and password
    3. Taps "Log In"
    4. System validates credentials
    5. User redirected to profile

    Verify: user is authenticated, profile data loads.

tc:auth:login-invalid:
  description: |
    User attempts login with wrong password.

    1. User opens login screen
    2. Enters email and wrong password
    3. Taps "Log In"
    4. System shows error toast
    5. User stays on login screen

    Verify: user not authenticated, can retry.

tc:auth:register-success:
  description: |
    New user creates account.

    1. User opens registration screen
    2. Fills name, email, phone, password
    3. Taps "Create Account"
    4. System creates user record
    5. User redirected to profile

    Verify: user created, authenticated.

# --- CART ---

tc:cart:add-product:
  description: |
    User adds product to cart.

    1. User views product details
    2. Taps "Add to Cart"
    3. System adds item or increments quantity
    4. Success toast shown

    Verify: cart updated, total recalculated.

tc:cart:checkout-flow:
  description: |
    User completes purchase.

    1. User views cart with items
    2. Taps "Proceed to Checkout"
    3. Selects delivery address
    4. Reviews order on confirmation screen
    5. Taps "Place Order"
    6. Order created, cart cleared
    7. Success dialog shown

    Verify: order in history, cart empty.
```

## Behavior Rules

- Never overwrite existing `_test-cases.yaml` without confirmation
- Always clean existing tc:* tags first (step 3) before generating new ones
- Always run check-tcs.ts at the end
- Continue until all screen/dialog/action/event entities are covered
- Use yq for all YAML modifications (not manual edits)
- Sort tags after adding new ones
- Schema path should be relative to the file location

## yq Commands Reference

```bash
# Remove all tc:* tags from file (or use utils/delete-tc-tags.ts)
yq -i 'del(.*.tags[] | select(startswith("tc:")))' file.yaml

# Add tag to entity
yq -i '.["entity:id"].tags += ["tc:epic:name"]' file.yaml

# Add tag with deduplication
yq -i '.["entity:id"].tags = (.["entity:id"].tags + ["tc:epic:name"] | unique)' file.yaml

# Sort tags
yq -i '.["entity:id"].tags |= sort' file.yaml

# List entities by pattern
yq 'to_entries | map(select(.key | test("^screen:"))) | .[].key' file.yaml

# Check if entity has tc:* tag
yq '.["entity:id"].tags | any(test("^tc:"))' file.yaml

# Get all entities without tc:* tags
yq 'to_entries | map(select(.value.tags | . == null or all(test("^tc:") | not))) | .[].key' file.yaml
```
